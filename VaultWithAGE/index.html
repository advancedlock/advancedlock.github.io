<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Vault With AGE</title>

<script src="StreamSaver.js"></script>
<script src="age.js"></script> 

<style>
  /* --- THEME: PURPLE STORM --- */
  :root { 
    --bg: #0a0a0a; --card: #141414; --text: #e0e0e0; 
    --accent: #7c4dff; --accent-hover: #651fff;
    --border: #333; --muted: #666; --danger: #ff5252; --success: #00e676; 
  }
  
  * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; outline: none; }
  
  body { 
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; 
    background: var(--bg); color: var(--text); padding: 20px; margin: 0; padding-bottom: 100px; 
    display: flex; flex-direction: column; align-items: center; 
  }
  .container { width: 100%; max-width: 700px; }

  h1 { font-size: 24px; text-transform: uppercase; letter-spacing: 2px; background: linear-gradient(90deg, #b388ff, var(--accent)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; text-align: center; margin: 10px 0 30px 0; font-weight: 900; }

  .card { background: var(--card); padding: 24px; border-radius: 16px; border: 1px solid var(--border); margin-bottom: 24px; box-shadow: 0 8px 24px rgba(0,0,0,0.4); }
  h2 { font-size: 14px; color: var(--muted); text-transform: uppercase; margin: 0 0 20px 0; display: flex; align-items: center; gap: 10px; }
  h2 span { color: var(--accent); font-size: 18px; }

  label { font-size: 11px; color: var(--muted); text-transform: uppercase; font-weight: bold; display: block; margin-bottom: 8px; margin-top: 20px; }
  input[type="text"], textarea { width: 100%; padding: 14px; background: #1f1f1f; border: 1px solid #333; border-radius: 8px; color: #fff; font-size: 14px; font-family: monospace; }
  input:focus, textarea:focus { border-color: var(--accent); outline: none; }

  .key-input { border-radius: 8px 8px 0 0 !important; text-align: center; border-bottom: none !important; color: var(--accent) !important; font-weight: bold; }
  .btn-copy-full { width: 100%; padding: 10px; background: #252525; border: 1px solid var(--border); border-top: 1px solid #333; border-radius: 0 0 8px 8px; color: var(--muted); font-size: 11px; font-weight: bold; cursor: pointer; text-transform: uppercase; }
  .btn-copy-full:hover { background: var(--accent); color: white; }

  .btn-action { background: var(--accent); color: white; border: none; padding: 16px; font-size: 14px; font-weight: bold; border-radius: 10px; cursor: pointer; width: 100%; text-transform: uppercase; margin-top: 20px; }
  .btn-action:disabled { background: #333; opacity: 0.5; cursor: not-allowed; }
  
  .btn-secondary { background: transparent; border: 1px dashed var(--border); color: var(--text); padding: 12px; width: 100%; border-radius: 8px; cursor: pointer; font-size: 13px; margin-bottom: 10px; text-transform: uppercase; }
  .btn-secondary:hover { border-color: var(--accent); color: var(--accent); }

  .tabs-container { display: flex; background: #111; border-radius: 12px 12px 0 0; border: 1px solid var(--border); border-bottom: none; margin-top: 10px; }
  .tab-btn { flex: 1; padding: 16px; background: transparent; border: none; color: var(--muted); font-size: 13px; font-weight: bold; text-transform: uppercase; cursor: pointer; border-bottom: 2px solid transparent; }
  .tab-btn.active { color: white; background: #181818; border-bottom: 2px solid var(--accent); }
  .tab-content { background: var(--card); border: 1px solid var(--border); border-top: none; border-radius: 0 0 16px 16px; padding: 24px; display: none; }
  .tab-content.active { display: block; }

  /* Drag & Drop Styles */
  .file-drop { border: 2px dashed #333; border-radius: 10px; padding: 25px 20px; text-align: center; cursor: pointer; background: #1a1a1a; font-weight: bold; font-size: 14px; transition: 0.2s; }
  .file-drop.dragover { border-color: var(--accent); background: rgba(124, 77, 255, 0.15); transform: scale(1.02); color: white; }

  .progress-wrap { height: 4px; background: #333; border-radius: 2px; margin-top: 20px; overflow: hidden; display: none; }
  .progress-bar { height: 100%; background: var(--accent); width: 0%; transition: width 0.1s linear; }
  .log-text { font-family: monospace; font-size: 11px; color: var(--muted); margin-top: 15px; text-align: center; }

  /* Checkbox Obfuscate */
  .checkbox-container { display: flex; align-items: center; gap: 10px; margin-top: 15px; background: #1a1a1a; padding: 10px; border-radius: 8px; border: 1px solid #333; }
  .checkbox-container input { width: 18px; height: 18px; accent-color: var(--accent); cursor: pointer; }
  .checkbox-container label { margin: 0; cursor: pointer; text-transform: none; font-weight: normal; color: #fff; font-size: 13px; }
</style>
</head>
<body>

<div class="container">
  <div class="card" style="text-align: center; padding: 15px;">
    <h1 style="margin:0;">Vault With AGE</h1>
  </div>

  <div class="card">
    <h2><span>üîë</span> Identity Management</h2>
    <button class="btn-secondary" onclick="generateKeys()">‚ö° Generate New Key Pair</button>
    <label>Private Key</label>
    <div><input type="text" id="privKey" class="key-input" readonly><button class="btn-copy-full" onclick="copyToClip('privKey', this)">COPY PRIVATE KEY</button></div>
    <label>Public Key</label>
    <div><input type="text" id="pubKey" class="key-input" readonly><button class="btn-copy-full" onclick="copyToClip('pubKey', this)">COPY PUBLIC KEY</button></div>
  </div>

  <div class="tabs-container">
    <button class="tab-btn active" onclick="openTab('encrypt')">üîí Encrypt</button>
    <button class="tab-btn" onclick="openTab('decrypt')">üîì Decrypt</button>
  </div>

  <div id="tab-encrypt" class="tab-content active">
    <input type="file" id="encInput" style="display:none" onchange="updateFileName(this, 'dropZoneEnc')">
    <div class="file-drop" id="dropZoneEnc" onclick="document.getElementById('encInput').click()"><span>üìÇ</span> Drop File Here or Click</div>
    
    <label>Recipients (Public Keys)</label>
    <textarea id="recipients" placeholder="age1..."></textarea>
    
    <div class="checkbox-container">
        <input type="checkbox" id="chkObfuscate" checked>
        <label for="chkObfuscate">Obfuscate Filename (Randomize name)</label>
    </div>

    <button class="btn-action" id="btnEncrypt" onclick="processStream('encrypt')">Encrypt & Stream</button>
    <div class="progress-wrap" id="progWrapEnc"><div class="progress-bar" id="progBarEnc"></div></div>
    <div id="logEnc" class="log-text"></div>
  </div>

  <div id="tab-decrypt" class="tab-content">
    <input type="file" id="decInput" style="display:none" onchange="updateFileName(this, 'dropZoneDec')">
    <div class="file-drop" id="dropZoneDec" onclick="document.getElementById('decInput').click()"><span>üîê</span> Drop .age File Here or Click</div>
    
    <label>Identity (Private Key)</label>
    <div><input type="text" id="decIdentity" class="key-input"><button class="btn-copy-full" onclick="pasteFromClip('decIdentity')">PASTE</button></div>
    
    <button class="btn-action" id="btnDecrypt" onclick="processStream('decrypt')">Decrypt & Stream</button>
    <div class="progress-wrap" id="progWrapDec"><div class="progress-bar" id="progBarDec"></div></div>
    <div id="logDec" class="log-text"></div>
  </div>
</div>

<script>
  // CONFIG
  try { if (typeof streamSaver !== 'undefined') streamSaver.mitm = 'mitm.html'; } catch(e) {}
  
  // MAGIC HEADER: "SAV1"
  const MAGIC = new Uint8Array([0x53, 0x41, 0x56, 0x01]); 

  // INIT & PREFERENCES
  window.addEventListener('load', () => {
    // 1. Load Obfuscate Preference (Default True if null)
    const chk = document.getElementById('chkObfuscate');
    const savedState = localStorage.getItem('age_obf');
    if (savedState !== null) {
        chk.checked = savedState === 'true';
    }
    // 2. Save Preference Listener
    chk.addEventListener('change', (e) => localStorage.setItem('age_obf', e.target.checked));

    // 3. Initialize Drag & Drop Handlers
    initDragDrop('dropZoneEnc', 'encInput');
    initDragDrop('dropZoneDec', 'decInput');
  });

  // UTILS UI
  function openTab(t) {
    document.querySelectorAll('.tab-content').forEach(e=>e.classList.remove('active'));
    document.querySelectorAll('.tab-btn').forEach(e=>e.classList.remove('active'));
    document.getElementById('tab-'+t).classList.add('active');
    event.target.classList.add('active');
  }
  function updateFileName(input, zoneId) {
    const z = document.getElementById(zoneId);
    if(input.files && input.files[0]) {
      z.innerHTML = `<span>üìÑ</span> ${input.files[0].name}`;
      z.style.borderColor = "var(--accent)"; z.style.color = "white";
    }
  }
  function copyToClip(id, btn) { document.getElementById(id).select(); document.execCommand('copy'); let old=btn.innerText; btn.innerText="COPIED!"; setTimeout(()=>btn.innerText=old, 1000); }
  async function pasteFromClip(id) { try{document.getElementById(id).value = await navigator.clipboard.readText();}catch(e){alert("Paste manually");} }

  // DRAG & DROP SYSTEM (Fixes flickering and upload issues)
  function initDragDrop(zoneId, inputId) {
    const zone = document.getElementById(zoneId);
    const input = document.getElementById(inputId);

    // Prevent default browser behavior (opening files) globally for drag events
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
      zone.addEventListener(eventName, preventDefaults, false);
      document.body.addEventListener(eventName, preventDefaults, false);
    });

    function preventDefaults(e) { e.preventDefault(); e.stopPropagation(); }

    // Highlight Zone
    ['dragenter', 'dragover'].forEach(eventName => {
      zone.addEventListener(eventName, () => zone.classList.add('dragover'), false);
    });
    ['dragleave', 'drop'].forEach(eventName => {
      zone.addEventListener(eventName, () => zone.classList.remove('dragover'), false);
    });

    // Handle Drop
    zone.addEventListener('drop', (e) => {
        const dt = e.dataTransfer;
        const files = dt.files;
        if(files.length > 0) {
            input.files = files; // Assign files to input
            updateFileName(input, zoneId); // Trigger UI update
        }
    });
  }

  // --- RANDOM FILENAME ---
  function generateRandomFilename() {
    const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
    const length = 24; 
    const randomValues = new Uint32Array(length);
    crypto.getRandomValues(randomValues);
    let result = "";
    for (let i = 0; i < length; i++) result += chars[randomValues[i] % chars.length];
    return result + ".age";
  }

  // LOGIC
  async function generateKeys() {
    if(typeof age === 'undefined') return alert("Error: age.js missing");
    const dist = await age.generateIdentity();
    document.getElementById('privKey').value = dist;
    document.getElementById('pubKey').value = await age.identityToRecipient(dist);
    // REMOVED: Auto-fill for Decrypt (Requested by user)
  }

  async function processStream(mode) {
    if(typeof age === 'undefined') return alert("Error: age.js missing");
    
    const isEnc = mode === 'encrypt';
    const file = document.getElementById(isEnc ? 'encInput' : 'decInput').files[0];
    if(!file) return alert("Select a file");

    const btn = document.getElementById(isEnc ? 'btnEncrypt' : 'btnDecrypt');
    const log = document.getElementById(isEnc ? 'logEnc' : 'logDec');
    const pBar = document.getElementById(isEnc ? 'progBarEnc' : 'progBarDec');
    const pWrap = document.getElementById(isEnc ? 'progWrapEnc' : 'progWrapDec');
    const obfuscate = isEnc ? document.getElementById('chkObfuscate').checked : false;

    btn.disabled = true; pWrap.style.display = 'block'; pBar.style.width = '0%';
    log.innerText = "Initializing...";

    try {
      let transformer;
      if (isEnc) {
        const recipients = document.getElementById('recipients').value.trim().split('\n').filter(r=>r.trim());
        if(!recipients.length) throw "No recipients";
        const enc = new age.Encrypter();
        recipients.forEach(r => enc.addRecipient(r.trim()));
        transformer = enc; 
      } else {
        const id = document.getElementById('decIdentity').value.trim();
        if(!id) throw "No identity";
        const dec = new age.Decrypter();
        dec.addIdentity(id);
        transformer = dec;
      }

      let inputStream = file.stream();
      let outputFilename = isEnc ? file.name + ".age" : file.name.replace(".age", "");

      // --- OBFUSCATION LOGIC ---
      if (isEnc && obfuscate) {
        const meta = new TextEncoder().encode(JSON.stringify({n: file.name}));
        const lenBuf = new Uint8Array(4);
        new DataView(lenBuf.buffer).setUint32(0, meta.length, true);
        const headerBlob = new Blob([MAGIC, lenBuf, meta]);
        
        inputStream = new ReadableStream({
            async start(controller) {
                const hReader = headerBlob.stream().getReader();
                while(true) { const {done, value} = await hReader.read(); if(done) break; controller.enqueue(value); }
                const fReader = file.stream().getReader();
                while(true) { const {done, value} = await fReader.read(); if(done) break; controller.enqueue(value); }
                controller.close();
            }
        });
        outputFilename = generateRandomFilename();
        log.innerText = "Encrypting with Chaos Filename...";
      }

      // EXECUTE
      const resultStreamPromise = isEnc ? transformer.encrypt(inputStream) : transformer.decrypt(inputStream);
      let finalStream = await resultStreamPromise;

      // --- RESTORATION LOGIC ---
      if (!isEnc) {
        const reader = finalStream.getReader();
        const { value: firstChunk, done } = await reader.read();
        
        if (!done) {
            let hasHeader = false;
            if (firstChunk.length >= 8) {
                const isMagic = firstChunk[0]===MAGIC[0] && firstChunk[1]===MAGIC[1] && firstChunk[2]===MAGIC[2] && firstChunk[3]===MAGIC[3];
                if (isMagic) {
                    const dv = new DataView(firstChunk.buffer, firstChunk.byteOffset, firstChunk.byteLength);
                    const metaLen = dv.getUint32(4, true); 
                    if (metaLen > 0 && metaLen < 5000 && firstChunk.length >= 8 + metaLen) {
                        try {
                            const jsonBytes = firstChunk.slice(8, 8 + metaLen);
                            const meta = JSON.parse(new TextDecoder().decode(jsonBytes));
                            if (meta.n) {
                                outputFilename = meta.n; 
                                hasHeader = true;
                                log.innerText = "Restored Name: " + meta.n;
                                const restChunk = firstChunk.slice(8 + metaLen);
                                finalStream = new ReadableStream({
                                    start(controller) { if (restChunk.length > 0) controller.enqueue(restChunk); },
                                    async pull(controller) {
                                        const {done, value} = await reader.read();
                                        if(done) return controller.close();
                                        controller.enqueue(value);
                                    }
                                });
                            }
                        } catch(e) {}
                    }
                }
            }
            if (!hasHeader) {
                finalStream = new ReadableStream({
                    start(controller) { controller.enqueue(firstChunk); },
                    async pull(controller) {
                         const {done, value} = await reader.read();
                         if(done) return controller.close();
                         controller.enqueue(value);
                    }
                });
            }
        }
      }

      // SAVE
      const fileWriter = streamSaver.createWriteStream(outputFilename);
      if (finalStream.pipeTo) {
          await finalStream.pipeTo(fileWriter);
      } else {
          const reader = finalStream.getReader();
          const writer = fileWriter.getWriter();
          while(true) { const {done, value} = await reader.read(); if(done) break; await writer.write(value); }
          writer.close();
      }

      pBar.style.width = '100%';
      log.innerText = "Success! File saved as: " + outputFilename;
      log.style.color = "var(--success)";

    } catch(e) {
      console.error(e);
      log.innerText = "Error: " + e.message;
      log.style.color = "var(--danger)";
    } finally {
      btn.disabled = false;
    }
  }
</script>
</body>
</html>